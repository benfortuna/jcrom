#summary The User Guide gives a brief description of JCROM to get you started.
#labels Featured

= What is JCROM? =

JCROM is an acronym that stands for Java Content Repository Object Mapper. It is a simple and lightweight annotation-based framework for mapping plain old java objects (POJOs) to/from nodes in a Java Content Repository. Before you can appreciate what it does for you, it is important to understand what a Java Content Repository (JCR) is.

== Java Content Repository (the JCR part of JCROM) ==

The [http://jcp.org/en/jsr/detail?id=170 JCR specification (JSR-170)] is one of the most exciting things to come out in the Java world lately. The JCR API is a standard, implementation independent, way to access content bi-directionally on a granular level to a content repository. It take the best of both the database and file system worlds, and adds a layer of extra services on top of that (versioning, full-text search, multi-valued properties, observations, etc.).

Although the spec has been out for a while (since 2005), JCR is now really starting to gain momentum with good open source implementations like [http://jackrabbit.apache.org Jackrabbit].

== Object Mapping (the OM part of JCROM) ==

We generally model our domain objects as Java classes. If we're storing information about hotels, we're likely to create a Hotel class, and add fields like title, description, address, rating, pictures, etc. It is easy to instantiate Java classes and add data to the fields, but when it comes to actually persisting the data we usually map the object to an external data source (such as database, xml files, or JCR). This often involves a lot of error prone boiler plate code (e.g. mapping from JDBC result set, or XML elements). The same applies, of course, when we need to load the data from the external data source into the Java object: more boiler plate code.

We already have good object mapping frameworks for JDBC, like Hibernate and the new Enterprise JavaBeans spec. There are also lots of solutions for mapping to/from XML. The vision of JCROM is to provide the same for JCR.

To see how JCROM can make things easier, consider the following example. Let's say we have a very simple Hotel class:

{{{
public class Hotel {

	private String name;
	private String description;
	private String phoneNumber;
	private int rating;
	
	private List<Restaurant> restaurants;
	
	// ... getters and setters
}
}}}

As you can see, each hotel has a list of restaurants. The Restaurant object is very simple as well:

{{{
public class Restaurant {
	
	private String name;
	private String description;
	private String phoneNumber;
	
	// ... getters and setters
}
}}}

To map a Hotel instance with a single restaurant to a JCR repository, we would need to do something like this (let's assume the Hotel object has been initialised with all relevant data):

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").addNode(hotel.getName());
	hotelNode.setProperty("description", hotel.getDescription());
	hotelNode.setProperty("phoneNumber", hotel.getPhoneNumber());
	hotelNode.setProperty("rating", hotel.getRating());
	
	Node restaurantContainer = hotelNode.addNode("restaurants");
	for ( Restaurant r : hotel.getRestaurants() ) {
		Node rNode = restaurantContainer.addNode(r.getName());
		rNode.setProperty("description", r.getDescription());
		rNode.setProperty("phoneNumber", r.getPhoneNumber());
	}
	session.save();
} finally {
	session.logout();
}
}}}

And if we wanted to load the Hotel back from the JCR, we'd have to do something like this:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);

	Hotel hotel = new Hotel();
	hotel.setName( node.getName() );
	hotel.setDescription( node.getProperty("description").getString() );
	hotel.setRating( node.getProperty("rating").getInt() );
	
	NodeIterator restaurantIterator = hotelNode.getNodes("restaurants");
	while ( restaurantIterator.hasNext() ) {
		Node rNode = restaurantIterator.nextNode();
		Restaurant restaurant = new Restaurant();
		restaurant.setName(rNode.getName());
		restaurant.setDescription(rNode.getProperty("description").getString());
		restaurant.setPhoneNumber(rNode.getProperty("phoneNumber").getString());
		hotel.addRestaurant(restaurant);
	}
	
} finally {
	session.logout();
}
}}}

This code is far from beautiful, and it gets messier with every field or child you add. Now, let's assume that we have annotated the Hotel and Restaurant classes with JCROM. We then create a new JCROM instance and map the objects we need:

{{{
Jcrom jcrom = new Jcrom();
jcrom.map(Hotel.class); // this will map Restaurant as well
}}}

Now that we have initialised Jcrom, we can map a Hotel instance to JCR:

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node parentNode = session.getRootNode().getNode("Hotels");
	jcrom.addNode(parentNode, hotel);
	
	session.save();
} finally {
	session.logout();
}
}}}

And in the same way we can load it from JCR:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);
	Hotel hotel = jcrom.fromNode(Hotel.class, hotelNode);
} finally {
	session.logout();
}
}}}

Pretty neat, huh? JCROM handles the mapping of nodes and child nodes, casting and assignment. And that's not all. The DAO support can abstract the JCR concepts even further, but more about that later in this guide.

== Summary ==

To summarise:
  * annotation based (needs Java 1.5)
  * lightweight, 32KB, only two external dependencies (JCR api and logging api)
  * simple to learn, easy to use (and test)
  * removes error prone boiler plate code
  * works with any JCR implementation
  * vision: do for JCR what Hibernate did for JDBC

What JCROM does not do at the moment:
  * support references
  * support same name siblings (not recommended anyway)
  * support mapping of legacy objects via XML

I find it easiest to explain by example. Therefore, this user guide is written more in a tutorial style than as a reference.

= Before we begin =

To use JCROM, you'll need the JCROM jar in your classpath. There are a few ways you can achieve this:

  * Download it directly from http://jcrom.org (note that you will need to download the external dependencies as well)
  * If you use Maven2 to manage your project, you can reference JCROM as a dependency:
  {{{
  <dependency>
	<groupId>org.jcrom</groupId>
	<artifactId>jcrom</artifactId>
	<version>1.0</version>
  </dependency>
  }}}
  * Finally, you can check out from subversion and build it yourself. You will need Maven2 for this. After you've checked out the project, cd into the jcrom folder, and run "mvn install".

= Annotating your Java classes =

To use JCROM, you need to be able to annotate the class you want to map. All the JCROM annotations are on the field level, except for one that is on the class level. I'll introduce the most important ones, and then give a table of all the annotations. Let's assume that we have the following Java class:

{{{
import java.util.Date;

public class WeblogEntry {

	private String title;
	private String excerpt;
	private String body;
	private Date publishDate;
	
	// ... getters and setters
}
}}}

We have four simple fields here. Let's look at the class after annotating it with JCROM annotations:

{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;
	
	public void setTitle( String title ) {
		this.title = title;
		this.name = title;
	}
	
	// ... other getters and setters
}
}}}

Two things to notice here. First of all, we've added a new field, "name", with the annotation @JcrName. The @JcrName annotation is mandatory: each class that is to be mapped using JCROM must have a String field that is annotated with @JcrName. This will be mapped to the node name, and will therefore represent the last token in the path to the node. The reason we've created another field, rather than use the title field, is that JCROM will clean the @JcrName field when mapping to a node name ("Hello, world!" would become "Hello_world"). We therefore store the original title in the title field, and the clean version in the name field (note that in the title setter we set the name as well). 

The second thing to notice, is that we have annotated the other fields using @JcrProperty. JCROM will map all fields annotated with @JcrProperty to a property on the node. For a list of valid property types, see the table later in this chapter. @JcrProperty can be also be used for multi-value properties, but such fields need to be mapped as java.util.List, parameterized with a valid field type (more on this in the annotation reference below).

In general, to annotate your object for JCROM, you do the following:

  # Annotate a String field with @JcrName. This will store the node name (cleaned up).
  # Annotate the class with @JcrNode if you need to specify a custom node type to map to.
  # Annotate fields with @JcrProperty. Multi-valued fields should be represented as a java.util.List with a valid property parameter.
  # Annotate child objects with @JcrChildNode. The child objects must be annotated with JCROM annotations. Multiple children are represented as a java.util.List, parameterized with the child object type.
  # Annotate parent object references with @JcrParentNode.
  # Annotate file objects with @JcrFileNode.
  # Annotate files for storing read-only JCR information with @JcrUUID, @JcrCreated, or @JcrPath.

I'll now describe these steps in more detail.

Note:
  * JCROM uses field level annotation, not method level. The fields can be private. Therefore there is no requirement for getter and setter methods.
  * JCROM handles inheritance, so annotations from superclasses are automatically detected.

== Node types ==

By default, JCROM maps objects to the nt:unstructured node type (the JcrFile class is an exception, more on that later!). This is handy for many cases, as it is a node type that allows any properties and child nodes. You can get up and running very quickly using this node type, and you can always add structure later.

However, if you have stricter requirements, and want to map your Java object to a custom node type, then you can use the @JcrNode annotation. This annotation is the only JCROM annotation that works on the type level (classes, interfaces). To map your class to a custom node type, simply annotate it as follows:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrNode;

@JcrNode(nodeType = "my:type")
public class MyClass {
	@JcrName private String name;
	...
}
}}}

== Properties ==

We can map fields to JCR node properties. There are two categories of properties.

=== Custom properties ===

You can map your Java fields to custom JCR properties using the @JcrProperty annotation. The following table shows which field types are valid for @JcrProperty annotation, and what JCR type they are mapped to:

|| *Java type* || *JCR type* ||
|| String || STRING ||
|| Boolean, boolean || BOOLEAN ||
|| Double, double || DOUBLE ||
|| Integer, int || DOUBLE ||
|| Long, long || LONG ||
|| byte[] || BINARY ||
|| java.io.InputStream || BINARY ||
|| java.util.Date || DATE ||
|| java.util.Calendar || DATE ||
|| java.sql.Timestamp || DATE ||

If we try to map a class with a @JcrProperty annotated field of type other than the above, we will get an exception telling us that the type is invalid.

We can map multi-valued properties using a java.util.List, as long as the List is parameterized with one of the Java types in the table above. For example, our WeblogEntry class might need a list of tags:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;
	
	...
}
}}}

The name of the JCR property will by default be the same as the name of the Java field. If you need to override this (for example to use namespaces), you can do so using the name parameter on the @JcrProperty annotation:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrProperty(name = "my:singleValue") private int mySingleValue;

    ...
}
}}}

=== Named read-only JCR properties ===

Depending on the node types and/or mixin types you use when mapping a Java object to JCR, the JCR will create default properties. JCROM provides a set of annotations to map to those read-only properties. This is useful if you want to use these properties in your Java code:

  * *@JcrUUID* - If the node has a generated UUID stored in a jcr:uuid property (e.g. it is of the mixin type mix:referenceable), then that value will be read into the field annotated with this annotation. This must be a String field.
  * *@JcrPath* - The full path to the node representing the Java object will be read into a field annotated with this annotation. This must be a String field.
  * *@JcrCreated* - If the node has a creation date stored in a jcr:created property (e.g. it is of a type that extends nt:hierarchyNode), then that value will be read into the field annotated with this annotation. 

== Child nodes ==

Often we have to deal with an object structure that is not just a flat list of fields, but rather a tree of objects. For example, our WeblogEntry class that we described above, might have an Author. For this purpose, JCROM has the @JcrChildNode annotation. With this annotation, we can specify that our class has a child field which itself needs to be mapped to a JCR node:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	
	...
}
}}}

We have to make sure that classes marked as child nodes are correctly annotated as well. So in this case we need to annotate the Author class accordingly:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class Author {
	@JcrName private String username;
	@JcrProperty private String firstName;
	@JcrProperty private String lastName;
	@JcrProperty private String emailAddress;
}
}}}

In a production environment, we would probably reference the author rather than including it, but this will do fine for demonstration purposes.

JCROM also supports mapping a list of children. This must be done using a java.util.List parameterized with the annotated child class. For example, our WeblogEntry class might need a list of comments. We would add this in the following way:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	@JcrChildNode private List<Comment> comments;
	
	...
}
}}}

And of course we would have to annotate the Comment class accordingly:

{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class Comment {

	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	...
}
}}}

The child nodes can have their own children if needed, and in fact there is no difference in the annotation of the parent or children classes. For example, each Comment should have an author, but I'll leave it like this for now.

JCROM creates a container node for each child node. The name of this container node is by default the field name, but if you need to customise the name, you can do so by specifying a name parameter on the @JcrChildNode annotation:

{{{
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrProperty(name = "my:singleValue") private int mySingleValue;
    @JcrChildNode(name = "my:child") private Child child;

    ...
}
}}}

To visualise how this container node mapping works, consider the following example. Let's say we have a WeblogEntry with the title "Hello world!", written by an author with the username "john", and with two comments. The node structure might then look like this (ignoring properties):

{{{
/Weblog/Hello_world
/Weblog/Hello_world/author/john
/Weblog/Hello_world/comments/I_like_your_post
/Weblog/Hello_world/comments/Me_too
}}}

== Parent references ==

If a child object needs to reference a parent object, then we can use the @JcrParentNode annotation inside the child object. For example, if a Comment needs a reference to its parent WeblogEntry object:


{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrParentNode;
import org.jcrom.annotations.JcrProperty;

public class Comment {

	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrParentNode private WeblogEntry weblogEntry;
	...
}
}}}

JCROM will notice this annotation when creating a WeblogEntry instance from a JCR node, and inject the parent WeblogEntry into each Comment. Note that JCROM will ignore this annotation if the parent object is not being loaded.

== Files ==

JCROM offers a few different strategies when mapping binary/file content. You can do this directly using a byte[] or java.io.InputStream field:

{{{
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrProperty private byte[] myImage;

    ...
}
}}}

But the recommended way is to map to a nt:file node, and JCROM supports this with the JcrFile class. To use the JcrFile class, the file node child needs to be annotated with @JcrFileNode. Let's assume we allow users to upload a single image with each WeblogEntry. We can implement this as follows:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.JcrFile;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrFileNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	@JcrChildNode private List<Comment> comments;

	@JcrFileNode private JcrFile image;
	
	...
}
}}}

JCROM will automatically create an nt:folder container node for the file, and map the JcrFile instance to an nt:file node within the folder. This is the recommended way of storing files in JCR.

The JcrFile node has fields that correspond (and map) to the nt:file properties and child nodes, such as last modified date, mime type, and encoding (optional). For accessing the file content, JcrFile has a JcrDataProvider field. The JcrDataProvider interface looks like this:

{{{
package org.jcrom;

import java.io.File;
import java.io.InputStream;

public interface JcrDataProvider {

	public enum TYPE {FILE, BYTES, STREAM}
	
	public TYPE getType();
	public File getFile();
	public byte[] getBytes();
	public InputStream getInputStream();
}
}}}

JCROM provides an implementation of this interface, which is used when reading a file node from JCR, and you can also use it when adding content to a JcrFile instance. For example, if we want to upload a file from a source to which we have an input stream:

{{{
...
WeblogEntry weblogEntry = ...;

String imageName = ...;
String imageMimeType = ...;
Calendar imageLastModified = ...;
InputStream imageStream = ...;

JcrFile image = new JcrFile();
image.setName(imageName);
image.setMimeType(imageMimeType);
image.setLastModified(imageLastModified);
image.setDataProvider( new JcrDataProviderImpl(JcrDataProvider.TYPE.STREAM, imageStream) );

weblogEntry.setImage(image);
...
}}}

JcrFile has static methods that can reduce the lines of code you write. For example, to create a JcrFile instance that has a data provider using a java.io.File, you can simply do:

{{{
String imageName = ...;
String imageMimeType = ...;
File imageFile = ...;

JcrFile jcrFile = JcrFile.fromFile(imageName, imageFile, imageMimeType);
}}}

If you have more complex requirements for accessing the file content when mapping to JCR, you can create your own implementation of JcrDataProvider, and add that to your JcrFile instance.

Often we need to store some custom metadata on our file nodes. For example, we may want to store information about the photographer with the image. To achieve this we must subclass JcrFile, and add the fields for the custom metadata:

{{{
import org.jcrom.annotations.JcrNode;
import org.jcrom.annotations.JcrProperty;

@JcrNode(nodeType = "nt:unstructured")
public class Image extends JcrFile {

    @JcrProperty private String photographer;

    public Image() {
        super();
    }
   
    ...
}
}}}

Note that we have to specify the nt:unstructured node type. The reason for this is that JcrFile will automatically map to the nt:file node type, but that node type does not allow our photographer property. Therefore we have specified the nt:unstructured node type. A better solution would be to create our own node type that would be a sub-type of nt:file, with our custom metadata properties specified, and use that for the mapping.

JCROM supports updating metdata only on file nodes. For example, you may just want to update the name of the photographer, leaving the file itself intact. To do this, just make sure that the data provider on JcrFile is null.

JCROM supports mapping a list of JcrFile nodes, using a java.util.List (much in the same way as for properties and children).

== Annotation reference ==

For detailed descriptions of each annotation type, consult the javadoc.

= Mapping objects to/from JCR =

Once you've annotated your objects, most of the hard work is done. Now all you need to do is create an instance of org.jcrom.Jcrom, add the classes you want to map, and then you can start mapping between nodes and objects.

== Create a Jcrom instance ==

The first thing you need to do is create a Jcrom instance, and tell it which classes you want to map. It is recommended that you create this instance once, and reuse it.

{{{
import org.jcrom.Jcrom;
...
Jcrom jcrom = new Jcrom();
jcrom.map(WeblogEntry.class);
...
}}}

Each class that you map will be validated, and a JcrMappinException will be thrown if the class is not valid for mapping. All child classes will be detected, validated, and mapped automatically. Therefore it is no need to map the Comment or Author classes above, since they are referenced as children from the WeblogEntry class.

== Mapping an object to a JCR node ==

Let's say we have an instance of a Java object, and want to map it to a JCR node. We can choose to either create a new node for our object, or update an existing one. The decision is left to the user, JCROM does not try to determine whether to add a node or update.

So if we wanted to create a new WeblogEntry, we would do:

{{{
Session session = ...;
Author me = ...;

WeblogEntry weblogEntry = new WeblogEntry();
weblogEntry.setTitle("Hello world!");
weblogEntry.setPublishDate(new Date());
weblogEntry.setBody("This is my first weblog entry!");
weblogEntry.setAuthor(me);

try {
    Node parentNode = session.getRootNode().getNode("Weblog"); 
    jcrom.addNode(parentNode, weblogEntry);
    session.save();
} finally {
    session.logout();
}
}}}

If you need to pass in mixin types when adding the node, then use another version of addNode():

{{{
...
String[] mixinTypes = {"mix:referenceable"};
jcrom.addNode(parentNode, weblogEntry, mixinTypes);
...
}}}

And then if we later want to add a comment to that WeblogEntry:

{{{
Session session = ...;

Comment comment = new Comment();
comment.setTitle("Nice post!");
comment.setBody("This is my first comment.");
comment.setPublishDate(new Date());
weblogEntry.addComment(comment);

try {
    jcrom.updateNode(weblogEntryNode, weblogEntry);
    session.save();
} finally {
    session.logout();
}
}}}

JCROM offers good control over which child nodes are updated during a call to updateNode(), more about that in the "Using filters" section.

== Creating an object instance from a JCR node ==

To create an instance of a Java object from a JCR node, we can simply do:

{{{
Session session = ...;
String weblogEntryName = ...;

try {
    Node weblogEntryNode = session.getRootNode()
        .getNode("Weblog").getNode(weblogEntryName);
    WeblogEntry weblogEntry = jcrom.fromNode(WeblogEntry.class, weblogEntryNode);
} finally {
    session.logout();
}
}}}

== Using filters ==

There are times when you don't want to load/update some/any child nodes. For example, we may want to list all the weblog entries, but without loading the comments for each entry. JCROM supports this with two parameters that can be used in the Jcrom.fromNode() and Jcrom.updateNode() methods:

  * _childNameFilter_ - this is a comma separated string with the names of children to include or exclude.

    * "comments" will include only the comments children
    * "-comments" will include everything but the comments children
    * "*" will include all children
    * "none" will exclude all children

  * _maxDepth_ - the maximum depth of included child nodes (0 means no child nodes are loaded, while a negative value means that no restrictions are set on the depth).

So, to load a weblog entry without the comments, we would do:

{{{
Session session = ...;
String weblogEntryName = ...;

try {
    Node weblogEntryNode = session.getRootNode()
        .getNode("Weblog").getNode(weblogEntryName);
    WeblogEntry weblogEntry 
        = jcrom.fromNode(WeblogEntry.class, weblogEntryNode, "-comments", -1);
} finally {
    session.logout();
}
}}}

In much the same way, sometimes we do not want to update the child nodes when updating a parent. For example, if we need to update the body property of the WeblogEntry, then there is no need to update all the comment child nodes. Therefore, the Jcrom.updateNode() methods accept the filter arguments as well.

= DAO support =

It is often wise to abstract the underlying persistence strategy away from the calling code, by encapsulating the persistence calls within Data Access Objects (DAOs). That means that your controller (or action) classes can have a DAO object injected, and use it, without having to worry whether the object is being persisted to a database, XML, or JCR. Also, session management can be kept outside the scope of controllers.

JCROM supports this methodology by providing a DAO interface, and an abstract DAO implementation that uses JCROM to map objects to/from JCR. The JcrDAO interface looks like this (refer to the javadoc for method documentation):

{{{
package org.jcrom.dao;

import java.util.List;
import javax.jcr.Node;

public interface JcrDAO<T> {

	public Node create( T entity ) throws Exception;
	public String update( T entity ) throws Exception;
	public String update( T entity, String oldName ) throws Exception;
	public String update( T entity, String childNodeFilter, int maxDepth ) throws Exception;
	public String update( T entity, String oldName, String childNodeFilter, int maxDepth ) throws Exception;
	public String updateByUUID( T entity, String uuid ) throws Exception;
	public String updateByUUID( T entity, String uuid, String childNodeFilter, int maxDepth ) throws Exception;
	public void delete( String name ) throws Exception;
	public void deleteByUUID( String uuid ) throws Exception;
	public boolean exists( String name ) throws Exception;
	public T get( String name ) throws Exception;
	public T get( String name, String childNodeFilter, int maxDepth ) throws Exception;
	public T loadByUUID( String uuid ) throws Exception;
	public T loadByUUID( String uuid, String childNodeFilter, int maxDepth ) throws Exception;
	public List<T> findAll() throws Exception;
	public List<T> findAll( long startIndex, long resultSize ) throws Exception;
	public List<T> findAll( String childNameFilter, int maxDepth ) throws Exception;
	public List<T> findAll( String childNameFilter, int maxDepth, long startIndex, long resultSize ) throws Exception;

}
}}}

JCROM offers an abstract implementation of this interface, AbstractJcrDAO, that implements all the methods (you can extend and add custom finder methods). Note that the finder methods can accept startIndex and resultSize arguments - this is useful when paginating over large result sets.

Let's look at how we could use the DAO support to simplify our WeblogEntry management. First of all, we would need to create a DAO class that extends AbstractJcrDAO:

{{{
import javax.jcr.Node;
import javax.jcr.Session;
import org.jcrom.Jcrom;
import org.jcrom.dao.AbstractJcrDAO;

public class WeblogEntryDAO extends AbstractJcrDAO<WeblogEntry> {

	private static final String ROOT_PATH = "Weblog";
	private static final String[] MIXIN_TYPES = {"mix:referenceable"};
	
	public WeblogEntryDAO( Session session, Jcrom jcrom ) {
		super(WeblogEntry.class, ROOT_PATH, session, jcrom, true, MIXIN_TYPES);
	}
}
}}}

Since all the methods are implemented for us, the only thing we need to do is implement a constructor. The constructor passes information on to the AbstractJcrDAO superclass (refer to the javadoc for description of the arguments). Now, we can use this class to persist and load weblog entries:

{{{
Jcrom jcrom = ...;
Session session = ...;
try {
    WeblogEntryDAO weblogEntryDAO = new WeblogEntryDAO(session, jcrom);

    WeblogEntry weblogEntry = weblogEntryDAO.get("Hello_world");
    weblogEntry.setExcerpt("This is the excerpt");

    weblogEntryDAO.update(weblogEntry);

} finally {
    session.logout();
}
}}}

In a web application environment, we would probably inject the Session and the Jcrom instance into the DAO, and then inject the DAO into a controller, so the controller would never directly deal with Jcrom or the Session.

I highly recommend using this approach, as it keeps your code tidy.

== Custom finder methods ==

Although the abstract DAO implementation has findAll() methods, we sometimes need custom finder methods to filter the data and apply custom sorting. The AbstractJcrDAO class provides a set of protected methods to make custom finder methods easier to create.

So, if we wanted to create a finder method that returns all posts where the title starts with a particular String, we could add the following method to the WeblogEntryDAO:

{{{
public List<WeblogEntry> findByStartChars( String chars ) throws Exception {
    return super.findByXPath("/jcr:root/" 
        + ROOT_PATH + "/*[jcr:like(@title, '" + chars + "%')]", "*", -1);
}
}}}

As you can see, adding custom finder methods is really easy.

= Using with Guice =

Guice is a lightweight annotation-based injection framework from Google. It is easy to use JCROM with Guice, just instantiate Jcrom in your Guice module, and bind it there. For example:

{{{
import com.google.inject.AbstractModule;
import org.jcrom.Jcrom;

public class MyGuiceModule extends AbstractModule {

	@Override
	protected void configure() {
		try {
			Jcrom jcrom = new Jcrom();
			jcrom.map(WeblogEntry.class);
			bind(Jcrom.class).toInstance(jcrom);
		} catch ( Exception e ) {
			// handle exception
		}
	}
}
}}}

And then you can inject Jcrom into your DAOs.