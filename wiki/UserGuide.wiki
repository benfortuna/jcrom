#summary The User Guide gives a brief description of JCROM to get you started. Written for version 1.2.
#labels Featured

= What is JCROM? =

JCROM is an acronym that stands for Java Content Repository Object Mapper. It is a simple and lightweight annotation-based framework for mapping plain old java objects (POJOs) to/from nodes in a Java Content Repository. Before you can appreciate what it does for you, it is important to understand what a Java Content Repository (JCR) is.

== Java Content Repository (the JCR part of JCROM) ==

The [http://jcp.org/en/jsr/detail?id=170 JCR specification (JSR-170)] is one of the most exciting things to come out in the Java world lately. The JCR API is a standard, implementation independent, way to access content bi-directionally on a granular level to a content repository. It take the best of both the database and file system worlds, and adds a layer of extra services on top of that (versioning, full-text search, multi-valued properties, observations, etc.).

Although the spec has been out for a while (since 2005), JCR is now really starting to gain momentum with good open source implementations like [http://jackrabbit.apache.org Jackrabbit].

== Object Mapping (the OM part of JCROM) ==

We generally model our domain objects as Java classes. If we're storing information about hotels, we're likely to create a Hotel class, and add fields like title, description, address, rating, pictures, etc. It is easy to instantiate Java classes and add data to the fields, but when it comes to actually persisting the data we usually map the object to an external data source (such as database, xml files, or JCR). This often involves a lot of error prone boiler plate code (e.g. mapping from JDBC result set, or XML elements). The same applies, of course, when we need to load the data from the external data source into the Java object: more boiler plate code.

We already have good object mapping frameworks for JDBC, like Hibernate and the new Enterprise JavaBeans spec. There are also lots of solutions for mapping to/from XML. The vision of JCROM is to provide the same for JCR.

To see how JCROM can make things easier, consider the following example. Let's say we have a very simple Hotel class:

{{{
public class Hotel {

	private String name;
	private String description;
	private String phoneNumber;
	private int rating;
	
	private List<Restaurant> restaurants;
	
	// ... getters and setters
}
}}}

As you can see, each hotel has a list of restaurants. The Restaurant object is very simple as well:

{{{
public class Restaurant {
	
	private String name;
	private String description;
	private String phoneNumber;
	
	// ... getters and setters
}
}}}

To map a Hotel instance with restaurants to a JCR repository, we would need to do something like this (let's assume the Hotel object has been initialised with all relevant data):

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").addNode(hotel.getName());
	hotelNode.setProperty("description", hotel.getDescription());
	hotelNode.setProperty("phoneNumber", hotel.getPhoneNumber());
	hotelNode.setProperty("rating", hotel.getRating());
	
	Node restaurantContainer = hotelNode.addNode("restaurants");
	for ( Restaurant r : hotel.getRestaurants() ) {
		Node rNode = restaurantContainer.addNode(r.getName());
		rNode.setProperty("description", r.getDescription());
		rNode.setProperty("phoneNumber", r.getPhoneNumber());
	}
	session.save();
} finally {
	session.logout();
}
}}}

And if we wanted to load the Hotel back from the JCR, we'd have to do something like this:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);

	Hotel hotel = new Hotel();
	hotel.setName( node.getName() );
	hotel.setDescription( node.getProperty("description").getString() );
	hotel.setRating( node.getProperty("rating").getInt() );
	
	NodeIterator restaurantIterator = hotelNode.getNodes("restaurants");
	while ( restaurantIterator.hasNext() ) {
		Node rNode = restaurantIterator.nextNode();
		Restaurant restaurant = new Restaurant();
		restaurant.setName(rNode.getName());
		restaurant.setDescription(rNode.getProperty("description").getString());
		restaurant.setPhoneNumber(rNode.getProperty("phoneNumber").getString());
		hotel.addRestaurant(restaurant);
	}
	
} finally {
	session.logout();
}
}}}

This code is far from beautiful, and it gets messier with every field or child you add. Now, let's assume that we have annotated the Hotel and Restaurant classes with JCROM. We then create a new JCROM instance and map the objects we need:

{{{
Jcrom jcrom = new Jcrom();
jcrom.map(Hotel.class); // this will map Restaurant as well
}}}

Now that we have initialised Jcrom, we can map a Hotel instance to JCR:

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node parentNode = session.getRootNode().getNode("Hotels");
	jcrom.addNode(parentNode, hotel);
	
	session.save();
} finally {
	session.logout();
}
}}}

And in the same way we can load it from JCR:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);
	Hotel hotel = jcrom.fromNode(Hotel.class, hotelNode);
} finally {
	session.logout();
}
}}}

Pretty neat, huh? JCROM handles the mapping of nodes and child nodes, casting and assignment. And that's not all. The DAO support can abstract the JCR concepts even further, but more about that later in this guide.

== Summary ==

To summarise:
  * annotation based (needs Java 1.5)
  * lightweight, 32KB, only two external dependencies (JCR api and logging api)
  * simple to learn, easy to use (and test)
  * removes error prone boiler plate code
  * works with any JCR implementation
  * vision: do for JCR what Hibernate did for JDBC

What JCROM does not do at the moment:
  * support mapping of legacy objects via XML

I find it easiest to explain by example. Therefore, this user guide is written more in a tutorial style than as a reference.

= Before we begin =

To use JCROM, you'll need the JCROM jar in your classpath. There are a few ways you can achieve this:

  * Download it directly from http://jcrom.org (note that you will need to download the external dependencies as well)
  * If you use Maven2 to manage your project, you can reference JCROM as a dependency:
  {{{
  <dependency>
	<groupId>org.jcrom</groupId>
	<artifactId>jcrom</artifactId>
	<version>1.1</version>
  </dependency>
  }}}
  * Finally, you can check out from subversion and build it yourself. You will need Maven2 for this. After you've checked out the project, cd into the jcrom folder, and run "mvn install".

= Annotating your Java classes =

To use JCROM, you need to be able to annotate the class you want to map. All the JCROM annotations are on the field level, except for one that is on the class level. I'll introduce the most important ones, and then give a table of all the annotations. Let's assume that we have the following Java class:

{{{
import java.util.Date;

public class WeblogEntry {

	private String title;
	private String excerpt;
	private String body;
	private Date publishDate;
	
	// ... getters and setters
}
}}}

We have four simple fields here. Let's look at the class after annotating it with JCROM annotations:

{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;
	
	public void setTitle( String title ) {
		this.title = title;
		this.name = title;
	}
	
	// ... other getters and setters
}
}}}

Two things to notice here. First of all, we've added a new field, "name", with the annotation @JcrName. The @JcrName annotation is mandatory: each class that is to be mapped using JCROM must have a String field that is annotated with @JcrName. This will be mapped to the node name, and will therefore represent the last token in the path to the node. The reason we've created another field, rather than use the title field, is that JCROM will clean the @JcrName field when mapping to a node name ("Hello, world!" would become "Hello_world"). We therefore store the original title in the title field, and the clean version in the name field (note that in the title setter we set the name as well). We've also added a "path" field, annotated with @JcrPath. This is also mandatory. The path field is a JCR read-only field that will contain the full path to the JCR node storing the object.

Note that the name cleanup can be turned off by using the Jcrom( boolean cleanName ) constructor.

The second thing to notice, is that we have annotated the other fields using @JcrProperty. JCROM will map all fields annotated with @JcrProperty to a property on the node. For a list of valid property types, see the table later in this chapter. @JcrProperty can be also be used for multi-value properties, but such fields need to be mapped as java.util.List, parameterized with a valid field type (more on this in the annotation reference below).

In general, to annotate your object for JCROM, you do the following:

  # Annotate a String field with @JcrName. This will store the node name. Mandatory.
  # Annotate a String field with @JcrPath. This will store the full node path. Mandatory.
  # Annotate the class with @JcrNode if you need to specify a custom node type to map to.
  # Annotate fields with @JcrProperty. Multi-valued fields should be represented as a java.util.List with a valid property parameter.
  # Annotate child objects with @JcrChildNode. The child objects must be annotated with JCROM annotations. Multiple children are represented as a java.util.List, parameterized with the child object type.
  # Annotate parent object references with @JcrParentNode.
  # Annotate file objects with @JcrFileNode.
  # Annotate files for storing read-only JCR information with @JcrUUID, @JcrCreated.

I'll now describe these steps in more detail.

Note:
  * JCROM uses field level annotation, not method level. The fields can be private. Therefore there is no requirement for getter and setter methods.
  * JCROM handles inheritance, so annotations from superclasses are automatically detected.

== Node types ==

By default, JCROM maps objects to the nt:unstructured node type (the JcrFile class is an exception, more on that later!). This is handy for many cases, as it is a node type that allows any properties and child nodes. You can get up and running very quickly using this node type, and you can always add structure later.

However, if you have stricter requirements, and want to map your Java object to a custom node type, then you can use the @JcrNode annotation. This annotation is the only JCROM annotation that works on the type level (classes, interfaces). To map your class to a custom node type, simply annotate it as follows:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrNode;

@JcrNode(nodeType = "my:type")
public class MyClass {
	@JcrName private String name;
	@JcrPath private String path;
	...
}
}}}

You can also use the @JcrNode annotation to specify mixin types to use when mapping an object to a JCR node:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrNode;

@JcrNode(mixinTypes = {"mix:referenceable"})
public class MyClass {
	@JcrName private String name;
	@JcrPath private String path;
	...
}
}}}

Note that mixinTypes takes an array, so you can specify multiple mixin types.

Finally, you can use the @JcrNode annotation to store the full canonical name of the class being mapped in a JCR property. For example:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrNode;

@JcrNode(classNameProperty = "className")
public class MyClass {
	@JcrName private String name;
	@JcrPath private String path;
	...
}
}}}

With the above annotation, JCROM would store the full name of the class in a property called "className" on the JCR node. This is important when using dynamic instantiation, which is described in a later section.

== Properties ==

We can map fields to JCR node properties. There are two categories of properties.

=== Custom properties ===

You can map your Java fields to custom JCR properties using the @JcrProperty annotation. The following table shows which field types are valid for @JcrProperty annotation, and what JCR type they are mapped to:

|| *Java type* || *JCR type* ||
|| String || STRING ||
|| Boolean, boolean || BOOLEAN ||
|| Double, double || DOUBLE ||
|| Integer, int || DOUBLE ||
|| Long, long || LONG ||
|| byte[] || BINARY ||
|| java.io.InputStream || BINARY ||
|| java.util.Date || DATE ||
|| java.util.Calendar || DATE ||
|| java.sql.Timestamp || DATE ||
|| java.util.Locale || STRING ||

If we try to map a class with a @JcrProperty annotated field of type other than the above, we will get an exception telling us that the type is invalid.

We can map multi-valued properties in one of two ways: 

 # using an array of the property type
 # using a java.util.List, as long as the List is parameterized with one of the Java types in the table above. 

For example, our WeblogEntry class might need a list of tags:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;
	
	...
}
}}}

The name of the JCR property will by default be the same as the name of the Java field. If you need to override this (for example to use namespaces), you can do so using the name parameter on the @JcrProperty annotation:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrPath private String path;
    @JcrProperty(name = "my:singleValue") private int mySingleValue;

    ...
}
}}}

=== Named read-only JCR properties ===

Depending on the node types and/or mixin types you use when mapping a Java object to JCR, the JCR will create default properties. JCROM provides a set of annotations to map to those read-only properties. This is useful if you want to use these properties in your Java code:

  * _@JcrUUID_ - If the node has a generated UUID stored in a jcr:uuid property (e.g. it is of the mixin type mix:referenceable), then that value will be read into the field annotated with this annotation. This must be a String field.
  * _@JcrCreated_ - If the node has a creation date stored in a jcr:created property (e.g. it is of a type that extends nt:hierarchyNode), then that value will be read into the field annotated with this annotation.
  * _@JcrCheckedout_ - For a versioned node, stores whether the node is checked out. Must be on a boolean field.
  * _@JcrBaseVersionName_ - For a versioned node, stores the name of the base version.
  * _@JcrBaseVersionCreated_ - For a versioned node, stores the creation date of the base version.
  * _@JcrVersionName_ - For a node version, stores the name of that version.
  * _@JcrVersionCreated_ - For a node version, stores the creation date of that version.

== Child nodes ==

Often we have to deal with an object structure that is not just a flat list of fields, but rather a tree of objects. For example, our WeblogEntry class that we described above, might have an Author. For this purpose, JCROM has the @JcrChildNode annotation. With this annotation, we can specify that our class has a child field which itself needs to be mapped to a JCR node:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	
	...
}
}}}

We have to make sure that classes marked as child nodes are correctly annotated as well. So in this case we need to annotate the Author class accordingly:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class Author {
	@JcrName private String username;
	@JcrPath private String path;
	@JcrProperty private String firstName;
	@JcrProperty private String lastName;
	@JcrProperty private String emailAddress;
}
}}}

In a production environment, we would probably reference the author rather than including it, but this will do fine for demonstration purposes.

JCROM also supports mapping a list of children. This must be done using a java.util.List parameterized with the annotated child class. For example, our WeblogEntry class might need a list of comments. We would add this in the following way:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	@JcrChildNode private List<Comment> comments;
	
	...
}
}}}

And of course we would have to annotate the Comment class accordingly:

{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class Comment {

	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	...
}
}}}

The child nodes can have their own children if needed, and in fact there is no difference in the annotation of the parent or children classes. For example, each Comment should have an author, but I'll leave it like this for now.

JCROM creates a container node for each child node. The name of this container node is by default the field name, but if you need to customise the name, you can do so by specifying a name parameter on the @JcrChildNode annotation:

{{{
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrPath private String path;
    @JcrProperty(name = "my:singleValue") private int mySingleValue;
    @JcrChildNode(name = "my:child") private Child child;

    ...
}
}}}

To visualise how this container node mapping works, consider the following example. Let's say we have a WeblogEntry with the title "Hello world!", written by an author with the username "john", and with two comments. The node structure might then look like this (ignoring properties):

{{{
/Weblog/Hello_world
/Weblog/Hello_world/author/john
/Weblog/Hello_world/comments/I_like_your_post
/Weblog/Hello_world/comments/Me_too
}}}

=== Maps as child nodes ===

With release 1.2, JCROM supports java.util.Map as a child node. JCROM will create an nt:unstructured node for the Map, and store each name-value pair in the Map as a property on that node. The Map must be parameterized with keys as java.lang.String, and values as a valid property type (or an array of such). The following is therefore valid:

{{{
import java.util.Map;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;

public class MyClass {

    @JcrName private String name;
    @JcrPath private String path;
    @JcrChildNode private Map<String,String> properties;

    ...
}
}}}

== Child objects as serialized properties ==

With release 1.2, JCROM supports storing a child object as a serializes byte array. To do this, mark your field with @JcrSerializedProperty. The object type must implement java.io.Serializable. For example:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrSerializedProperty;

public class MyClass {

    @JcrName private String name;
    @JcrPath private String path;
    @JcrSerializedProperty private MyChild child;

    ...
}
}}}

In the above case, JCROM will automatically serialize the child object, and store as a byte array in JCR. This of course works both ways, so when reading the object from JCR, JCROM will deserialize the byte array and add the resulting object to the child field.

== References ==

JCROM supports JCR references using the @JcrReference annotation. For example, if we wanted to reference an Author from a WeblogEntry (instead of storing it as a child node), we would annotated as follows:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;
import org.jcrom.annotations.JcrReference;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private List<Comment> comments;

	@JcrReference private Author author;	
	...
}
}}} 

A few things to mention about the reference support:

  * The field type class of a reference field MUST have a @JcrUUID annotated field. In the above example, this means that the Author class must have a @JcrUUID field.
  * When JCROM maps a node to an object, and a @JcrReference is found, then that referenced node will be loaded, and mapped to an object. In the above example, that means that when a WeblogEntry is loaded from a node, the author will also be loaded and mapped by JCROM automatically.
  * When JCROM maps an object with a @JcrReference to a node, it does it in the following way:
    # Retrieve the value of the @JcrUUID annotated field in the reference object.
    # Use the UUID to load the node being referenced.
    # Create a property referencing the loaded node.
  * The filtering and max depth arguments in the Jcrom methods apply in same way to references as child nodes.

Therefore, if we were creating a new WeblogEntry, it is enough for us to know the Author UUID:

{{{
...
String authorUUID = ...;
Author author = new Author();
author.setUuid(authorUUID);

WeblogEntry entry = new WeblogEntry();
entry.setAuthor(author);
...
}}}

== Parent nodes ==

If a child object needs to reference a parent object, then we can use the @JcrParentNode annotation inside the child object. For example, if a Comment needs a reference to its parent WeblogEntry object:


{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrParentNode;
import org.jcrom.annotations.JcrProperty;

public class Comment {

	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrParentNode private WeblogEntry weblogEntry;
	...
}
}}}

JCROM will notice this annotation when creating a WeblogEntry instance from a JCR node, and inject the parent WeblogEntry into each Comment. Note that JCROM will ignore this annotation if the parent object is not being loaded.

== Files ==

JCROM offers a few different strategies when mapping binary/file content. You can do this directly using a byte[] or java.io.InputStream field:

{{{
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrPath private String path;
    @JcrProperty private byte[] myImage;

    ...
}
}}}

But the recommended way is to map to a nt:file node, and JCROM supports this with the JcrFile class. To use the JcrFile class, the file node child needs to be annotated with @JcrFileNode. Let's assume we allow users to upload a single image with each WeblogEntry. We can implement this as follows:

{{{
import java.util.Date;
import java.util.List;
import org.jcrom.JcrFile;
import org.jcrom.annotations.JcrChildNode;
import org.jcrom.annotations.JcrFileNode;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrPath;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrPath private String path;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;

	@JcrProperty private List<String> tags;

	@JcrChildNode private Author author;
	@JcrChildNode private List<Comment> comments;

	@JcrFileNode private JcrFile image;
	
	...
}
}}}

JCROM will automatically create an nt:folder container node for the file, and map the JcrFile instance to an nt:file node within the folder. This is the recommended way of storing files in JCR.

The JcrFile node has fields that correspond (and map) to the nt:file properties and child nodes, such as last modified date, mime type, and encoding (optional). For accessing the file content, JcrFile has a JcrDataProvider field. The JcrDataProvider interface looks like this:

{{{
package org.jcrom;

import java.io.File;
import java.io.InputStream;

public interface JcrDataProvider {

	public enum TYPE {FILE, BYTES, STREAM}
	
	public TYPE getType();
	public File getFile();
	public byte[] getBytes();
	public InputStream getInputStream();
}
}}}

JCROM provides an implementation of this interface, which is used when reading a file node from JCR, and you can also use it when adding content to a JcrFile instance. For example, if we want to upload a file from a source to which we have an input stream:

{{{
...
WeblogEntry weblogEntry = ...;

String imageName = ...;
String imageMimeType = ...;
Calendar imageLastModified = ...;
InputStream imageStream = ...;

JcrFile image = new JcrFile();
image.setName(imageName);
image.setMimeType(imageMimeType);
image.setLastModified(imageLastModified);
image.setDataProvider( new JcrDataProviderImpl(JcrDataProvider.TYPE.STREAM, imageStream) );

weblogEntry.setImage(image);
...
}}}

JcrFile has static methods that can reduce the lines of code you write. For example, to create a JcrFile instance that has a data provider using a java.io.File, you can simply do:

{{{
String imageName = ...;
String imageMimeType = ...;
File imageFile = ...;

JcrFile jcrFile = JcrFile.fromFile(imageName, imageFile, imageMimeType);
}}}

If you have more complex requirements for accessing the file content when mapping to JCR, you can create your own implementation of JcrDataProvider, and add that to your JcrFile instance.

Often we need to store some custom metadata on our file nodes. For example, we may want to store information about the photographer with the image. To achieve this we must subclass JcrFile, and add the fields for the custom metadata:

{{{
import org.jcrom.annotations.JcrNode;
import org.jcrom.annotations.JcrProperty;

@JcrNode(nodeType = "nt:unstructured")
public class Image extends JcrFile {

    @JcrProperty private String photographer;

    public Image() {
        super();
    }
   
    ...
}
}}}

Note that we have to specify the nt:unstructured node type. The reason for this is that JcrFile will automatically map to the nt:file node type, but that node type does not allow our photographer property. Therefore we have specified the nt:unstructured node type. A better solution would be to create our own node type that would be a sub-type of nt:file, with our custom metadata properties specified, and use that for the mapping.

JCROM supports updating metdata only on file nodes. For example, you may just want to update the name of the photographer, leaving the file itself intact. To do this, just make sure that the data provider on JcrFile is null.

JCROM supports mapping a list of JcrFile nodes, using a java.util.List (much in the same way as for properties and children).

== Annotation reference ==

For detailed descriptions of each annotation type, consult the javadoc.

= Mapping objects to/from JCR =

Once you've annotated your objects, most of the hard work is done. Now all you need to do is create an instance of org.jcrom.Jcrom, add the classes you want to map, and then you can start mapping between nodes and objects.

== Create a Jcrom instance ==

The first thing you need to do is create a Jcrom instance, and tell it which classes you want to map. It is recommended that you create this instance once, and reuse it.

{{{
import org.jcrom.Jcrom;
...
Jcrom jcrom = new Jcrom();
jcrom.map(WeblogEntry.class);
...
}}}

Each class that you map will be validated, and a JcrMappinException will be thrown if the class is not valid for mapping. All child classes will be detected, validated, and mapped automatically. Therefore it is no need to map the Comment or Author classes above, since they are referenced as children from the WeblogEntry class.

== Mapping an object to a JCR node ==

Let's say we have an instance of a Java object, and want to map it to a JCR node. We can choose to either create a new node for our object, or update an existing one. The decision is left to the user, JCROM does not try to determine whether to add a node or update.

So if we wanted to create a new WeblogEntry, we would do:

{{{
Session session = ...;
Author me = ...;

WeblogEntry weblogEntry = new WeblogEntry();
weblogEntry.setTitle("Hello world!");
weblogEntry.setPublishDate(new Date());
weblogEntry.setBody("This is my first weblog entry!");
weblogEntry.setAuthor(me);

try {
    Node parentNode = session.getRootNode().getNode("Weblog"); 
    jcrom.addNode(parentNode, weblogEntry);
    session.save();
} finally {
    session.logout();
}
}}}

If you need to pass in mixin types when adding the node, then use another version of addNode():

{{{
...
String[] mixinTypes = {"mix:referenceable"};
jcrom.addNode(parentNode, weblogEntry, mixinTypes);
...
}}}

And then if we later want to add a comment to that WeblogEntry:

{{{
Session session = ...;

Comment comment = new Comment();
comment.setTitle("Nice post!");
comment.setBody("This is my first comment.");
comment.setPublishDate(new Date());
weblogEntry.addComment(comment);

try {
    jcrom.updateNode(weblogEntryNode, weblogEntry);
    session.save();
} finally {
    session.logout();
}
}}}

JCROM offers good control over which child nodes are updated during a call to updateNode(), more about that in the "Using filters" section.

== Creating an object instance from a JCR node ==

To create an instance of a Java object from a JCR node, we can simply do:

{{{
Session session = ...;
String weblogEntryName = ...;

try {
    Node weblogEntryNode = session.getRootNode()
        .getNode("Weblog").getNode(weblogEntryName);
    WeblogEntry weblogEntry = jcrom.fromNode(WeblogEntry.class, weblogEntryNode);
} finally {
    session.logout();
}
}}}

== Using filters ==

There are times when you don't want to load/update some/any child nodes. For example, we may want to list all the weblog entries, but without loading the comments for each entry. JCROM supports this with two parameters that can be used in the Jcrom.fromNode() and Jcrom.updateNode() methods:

  * _childNameFilter_ - this is a comma separated string with the names of children to include or exclude.

    * "comments" will include only the comments children
    * "-comments" will include everything but the comments children
    * star will include all children
    * "none" will exclude all children

  * _maxDepth_ - the maximum depth of included child nodes (0 means no child nodes are loaded, while a negative value means that no restrictions are set on the depth).

So, to load a weblog entry without the comments, we would do:

{{{
Session session = ...;
String weblogEntryName = ...;

try {
    Node weblogEntryNode = session.getRootNode()
        .getNode("Weblog").getNode(weblogEntryName);
    WeblogEntry weblogEntry 
        = jcrom.fromNode(WeblogEntry.class, weblogEntryNode, "-comments", -1);
} finally {
    session.logout();
}
}}}

In much the same way, sometimes we do not want to update the child nodes when updating a parent. For example, if we need to update the body property of the WeblogEntry, then there is no need to update all the comment child nodes. Therefore, the Jcrom.updateNode() methods accept the filter arguments as well.

= Programming to interfaces: Dynamic instantiation =

New in release 1.2 is the ability to determine the class of the object to instantiate from a JCR property. This is especially important when programming to interfaces. In that case we have a child node as an interface, and then the actual implementation class used can depend on circumstances.

To use this feature, you need to do the following:

 # Add a @JcrNode(classNameProperty="className") annotation to the interface.
 # Map the implementing classes (not the interface!) in JCROM.
 # Instantiate Jcrom with the dynamicInstantiation flag set to true.
 # Use Jcrom to map to/from the interface.

For example, let's say we have a Shape interface:

{{{
import org.jcrom.JcrEntity;
import org.jcrom.annotations.JcrNode;

@JcrNode(classNameProperty="className")
public interface Shape extends JcrEntity {

	public double getArea();
}
}}}

Note that we have added a @JcrNode annotation, where we specify that the name of the
class should be stored in a JCR property on the node (we've set the name of the
property to "className"). If your node is of type nt:unstructured (default) then
there are no problems here, but if not, then you may need to create a mixin type that
supports the className property.

Also note that the interface does not need to extend the JcrEntity interface. This is just a convenience interface that has getters and setters for name and path.

Then we can have classes that implement the Shape interface:

{{{
import org.jcrom.AbstractJcrEntity;
import org.jcrom.annotations.JcrProperty;

public class Circle extends AbstractJcrEntity implements Shape {

	@JcrProperty private double radius;
	
	public Circle() {
	}
	
	public Circle( double radius ) {
		super();
		this.radius = radius;
	}
	
	public double getArea() {
		return Math.PI * (radius * radius);
	}

	public double getRadius() {
		return radius;
	}
}
}}}

and 
{{{
import org.jcrom.AbstractJcrEntity;
import org.jcrom.annotations.JcrProperty;

public class Rectangle extends AbstractJcrEntity implements Shape {

	@JcrProperty private double height;
	@JcrProperty private double width;
	
	public Rectangle() {
	}
	
	public Rectangle( double height, double width ) {
		super();
		this.height = height;
		this.width = width;
	}
	
	public double getArea() {
		return height * width;
	}

	public double getHeight() {
		return height;
	}

	public double getWidth() {
		return width;
	}
}
}}}

Then these classes can be mapped as follows:

{{{
	Jcrom jcrom = new Jcrom(true, true);
	jcrom.map(Circle.class)
		.map(Rectangle.class);
		
	Shape circle = new Circle(5);
	circle.setName("circle");
		
	Shape rectangle = new Rectangle(5,5);
	rectangle.setName("rectangle");
		
	Node rootNode = session.getRootNode().addNode("dynamicInstTest");
	Node circleNode = jcrom.addNode(rootNode, circle);
	Node rectangleNode = jcrom.addNode(rootNode, rectangle);
	session.save();
		
	Shape circleFromNode = jcrom.fromNode(Shape.class, circleNode);
	Shape rectangleFromNode = jcrom.fromNode(Shape.class, rectangleNode);
}}}

Note that we use a different Jcrom constructor the above example:

{{{
Jcrom jcrom = new Jcrom(true, true);
}}}

This specifies that the Jcrom instance will clean node names (first parameter), and
use dynamic instantiation (second parameter). When using interfaces, the dynamic instantiation MUST be turned on using this parameter, or else the mapping will not work.

Note that this can also be used for mapping child nodes to interfaces. For example:

{{{
import java.util.ArrayList;
import java.util.List;
import org.jcrom.annotations.JcrChildNode;

public class ShapeContainer extends AbstractJcrEntity {

	@JcrChildNode private List<Shape> shapes;
	
	public ShapeContainer() {
		super();
		this.shapes = new ArrayList<Shape>();
	}

	public List<Shape> getShapes() {
		return shapes;
	}
	
	public void addShape( Shape shape ) {
		shapes.add(shape);
	}

	public void setShapes(List<Shape> shapes) {
		this.shapes = shapes;
	}

}
}}}

The ShapeContainer has a list of Shapes. JCROM will automatically store the class name of the implementing Shape class in a JCR property, and then use this to dynamically instantiate the correct implementation when creating a Shape object from a JCR node.

= DAO support =

It is often wise to abstract the underlying persistence strategy away from the calling code, by encapsulating the persistence calls within Data Access Objects (DAOs). That means that your controller (or action) classes can have a DAO object injected, and use it, without having to worry whether the object is being persisted to a database, XML, or JCR. Also, session management can be kept outside the scope of controllers.

JCROM supports this methodology by providing a DAO interface, and an abstract DAO implementation that uses JCROM to map objects to/from JCR. The JcrDAO interface looks like this (refer to the javadoc for method documentation):

{{{
package org.jcrom.dao;

import java.util.List;
import javax.jcr.Node;

public interface JcrDAO<T> {

	public Node create( T entity ) throws Exception;
	
	public String update( T entity ) throws Exception;
	public String update( T entity, String childNameFilter, int maxDepth ) throws Exception;
	public String updateByUUID( T entity, String uuid ) throws Exception;
	public String updateByUUID( T entity, String uuid, String childNameFilter, int maxDepth ) throws Exception;
		
	public void delete( String path ) throws Exception;
	public void deleteByUUID( String uuid ) throws Exception;

	public boolean exists( String path ) throws Exception;

	public T get( String path ) throws Exception;
	public T get( String path, String childNodeFilter, int maxDepth ) throws Exception;
	
	public T loadByUUID( String uuid ) throws Exception;
	public T loadByUUID( String uuid, String childNodeFilter, int maxDepth ) throws Exception;
	
	public List<T> getVersionList( String path ) throws Exception;
	public List<T> getVersionList( String path, String childNameFilter, int maxDepth ) throws Exception;
	public List<T> getVersionList( String path, String childNameFilter, int maxDepth, long startIndex, long resultSize ) throws Exception;
	
	public List<T> getVersionListByUUID( String uuid ) throws Exception;
	public List<T> getVersionListByUUID( String uuid, String childNameFilter, int maxDepth ) throws Exception;
	public List<T> getVersionListByUUID( String uuid, String childNameFilter, int maxDepth, long startIndex, long resultSize ) throws Exception;
	
	public long getVersionSize( String path ) throws Exception;
	public long getVersionSizeByUUID( String uuid ) throws Exception;
	
	public T getVersion( String path, String versionName ) throws Exception;
	public T getVersion( String path, String versionName, String childNodeFilter, int maxDepth ) throws Exception;
	
	public T getVersionByUUID( String uuid, String versionName ) throws Exception;
	public T getVersionByUUID( String uuid, String versionName, String childNodeFilter, int maxDepth ) throws Exception;
	
	public void restoreVersion( String path, String versionName ) throws Exception;
	public void restoreVersionByUUID( String uuid, String versionName ) throws Exception;
	
	public void removeVersion( String path, String versionName ) throws Exception;
	public void removeVersionByUUID( String uuid, String versionName ) throws Exception;
	
	public long getSize( String rootPath ) throws Exception;
	
	public List<T> findAll( String rootPath ) throws Exception;
	public List<T> findAll( String rootPath, long startIndex, long resultSize ) throws Exception;
	public List<T> findAll( String rootPath, String childNameFilter, int maxDepth ) throws Exception;
	public List<T> findAll( String rootPath, String childNameFilter, int maxDepth, long startIndex, long resultSize ) throws Exception;

}
}}}

JCROM offers an abstract implementation of this interface, AbstractJcrDAO, that implements all the methods (you can extend and add custom finder methods). Note that the finder methods can accept startIndex and resultSize arguments - this is useful when paginating over large result sets.

Let's look at how we could use the DAO support to simplify our WeblogEntry management. First of all, we would need to create a DAO class that extends AbstractJcrDAO:

{{{
import javax.jcr.Node;
import javax.jcr.Session;
import org.jcrom.Jcrom;
import org.jcrom.dao.AbstractJcrDAO;

public class WeblogEntryDAO extends AbstractJcrDAO<WeblogEntry> {

	private static final String[] MIXIN_TYPES = {"mix:referenceable"};
	
	public WeblogEntryDAO( Session session, Jcrom jcrom ) {
		super(WeblogEntry.class, session, jcrom, MIXIN_TYPES);
	}
}
}}}

Since all the methods are implemented for us, the only thing we need to do is implement a constructor. The constructor passes information on to the AbstractJcrDAO superclass (refer to the javadoc for description of the arguments). Now, we can use this class to persist and load weblog entries:

{{{
Jcrom jcrom = ...;
Session session = ...;
String weblogEntryPath = ...;
try {
    WeblogEntryDAO weblogEntryDAO = new WeblogEntryDAO(session, jcrom);

    WeblogEntry weblogEntry = weblogEntryDAO.get(weblogEntryPath);
    weblogEntry.setExcerpt("This is the excerpt");

    weblogEntryDAO.update(weblogEntry);

} finally {
    session.logout();
}
}}}

In a web application environment, we would probably inject the Session and the Jcrom instance into the DAO, and then inject the DAO into a controller, so the controller would never directly deal with Jcrom or the Session.

I highly recommend using this approach, as it keeps your code tidy.

== Custom finder methods ==

Although the abstract DAO implementation has findAll() methods, we sometimes need custom finder methods to filter the data and apply custom sorting. The AbstractJcrDAO class provides a set of protected methods to make custom finder methods easier to create.

So, if we wanted to create a finder method that returns all posts where the title starts with a particular String, we could add the following method to the WeblogEntryDAO:

{{{
public List<WeblogEntry> findByStartChars( String chars ) throws Exception {
    return super.findByXPath("/jcr:root/" 
        + ROOT_PATH + "/*[jcr:like(@title, '" + chars + "%')]", "*", -1);
}
}}}

As you can see, adding custom finder methods is really easy.

== Versioning ==

The DAO implementation handles versioning transparently. If "mix:versionable" is one of the mixin types, then the AbstractJcrDAO class will automatically perform checkout and checkin on all write operations. Retrieving all versions of a node using the JCR API is a bit complex and needs many lines of code. The DAO simplifies this task with methods that retrieve the versions and automatically map to objects:

{{{
Jcrom jcrom = ...;
Session session = ...;
try {
    VersionedDAO versionedDao = new VersionedDAO(session, jcrom);
    
    VersionedEntity entity = new VersionedEntity();
    entity.setBody("first");
    // set other values
    ...

    versionedDao.create(entity); // this creates the first version

    entity.setBody("second");
    versionedDao.update(entity); // this creates a new version

    // we can get a list of all versions
    List<VersionedEntity> versions = versionedDao.getVersionList(entity.getPath());

    // we can also get one specific version
    VersionedEntity oldEntity = versionedDao.getVersion(entity.getPath(), "1.0");

    // and we can restore a version
    versionedDao.restoreVersion(entity.getPath(), "1.0");
 
} finally {
    session.logout();
}
}}}

= Using with Guice =

Guice is a lightweight annotation-based dependency injection framework from Google. It is easy to use JCROM with Guice, just instantiate Jcrom in your Guice module, and bind it there. For example:

{{{
import com.google.inject.AbstractModule;
import org.jcrom.Jcrom;

public class MyGuiceModule extends AbstractModule {

	@Override
	protected void configure() {
		try {
			Jcrom jcrom = new Jcrom();
			jcrom.map(WeblogEntry.class);
			bind(Jcrom.class).toInstance(jcrom);
		} catch ( Exception e ) {
			// handle exception
		}
	}
}
}}}

And then you can inject Jcrom into your DAOs.

= Using with Spring =

Spring is a very popular dependency injection framework. It is easy to use JCROM with Spring, just construct a Jcrom instance with constructor based injection, supplying the classes to be mapped in the constructor. For example:

{{{
...
  <bean id="jcrom" class="org.jcrom.Jcrom">
    <constructor-arg type="java.util.Set">
      <set>
        <value type="java.lang.Class">com.mypackage.MyClass1</value>
        <value type="java.lang.Class">com.mypackage.MyClass2</value>
      </set>
    </constructor-arg>
  </bean>
...
}}}