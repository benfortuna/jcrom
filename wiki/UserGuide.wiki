#summary The User Guide gives a brief description of JCROM to get you started.
#labels Featured

= What is JCROM? =

JCROM is an acronym that stands for Java Content Repository Object Mapper. It is a simple and lightweight annotation-based framework for mapping plain old java objects (POJOs) to/from nodes in a Java Content Repository. Before you can appreciate what it does for you, it is important to understand what a Java Content Repository (JCR) is.

== Java Content Repository (the JCR part of JCROM) ==

The [http://jcp.org/en/jsr/detail?id=170 JCR specification (JSR-170)] is one of the most exciting things to come out in the Java world lately. The JCR API is a standard, implementation independent, way to access content bi-directionally on a granular level to a content repository. It take the best of both the database and file system worlds, and adds a layer of extra services on top of that (versioning, full-text search, multi-valued properties, observations, etc.).

Although the spec has been out for a while (since 2005), JCR is now really starting to gain momentum with good open source implementations like [http://jackrabbit.apache.org Jackrabbit].

== Object Mapping (the OM part of JCROM) ==

We generally model our domain objects as Java classes. If we're storing information about hotels, we're likely to create a Hotel class, and add fields like title, description, address, rating, pictures, etc. It is easy to instantiate Java classes and add data to the fields, but when it comes to actually persisting the data we usually map the object to an external data source (such as database, xml files, or JCR). This often involves a lot of error prone boiler plate code (e.g. mapping from JDBC result set, or XML elements). The same applies, of course, when we need to load the data from the external data source into the Java object: more boiler plate code.

We already have good object mapping frameworks for JDBC, like Hibernate and the new Enterprise JavaBeans spec. There are also lots of solutions for mapping to/from XML. The vision of JCROM is to provide the same for JCR.

To see how JCROM can make things easier, consider the following example. Let's say we have a very simple Hotel class:

{{{
public class Hotel {

	private String name;
	private String description;
	private String phoneNumber;
	private int rating;
	
	private List<Restaurant> restaurants;
	
	// ... getters and setters
}
}}}

As you can see, each hotel has a list of restaurants. The Restaurant object is very simple as well:

{{{
public class Restaurant {
	
	private String name;
	private String description;
	private String phoneNumber;
	
	// ... getters and setters
}
}}}

To map a Hotel instance with a single restaurant to a JCR repository, we would need to do something like this (let's assume the Hotel object has been initialised with all relevant data):

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").addNode(hotel.getName());
	hotelNode.setProperty("description", hotel.getDescription());
	hotelNode.setProperty("phoneNumber", hotel.getPhoneNumber());
	hotelNode.setProperty("rating", hotel.getRating());
	
	Node restaurantContainer = hotelNode.addNode("restaurants");
	for ( Restaurant r : hotel.getRestaurants() ) {
		Node rNode = restaurantContainer.addNode(r.getName());
		rNode.setProperty("description", r.getDescription());
		rNode.setProperty("phoneNumber", r.getPhoneNumber());
	}
	session.save();
} finally {
	session.logout();
}
}}}

And if we wanted to load the Hotel back from the JCR, we'd have to do something like this:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);

	Hotel hotel = new Hotel();
	hotel.setName( node.getName() );
	hotel.setDescription( node.getProperty("description").getString() );
	hotel.setRating( node.getProperty("rating").getInt() );
	
	NodeIterator restaurantIterator = hotelNode.getNodes("restaurants");
	while ( restaurantIterator.hasNext() ) {
		Node rNode = restaurantIterator.nextNode();
		Restaurant restaurant = new Restaurant();
		restaurant.setName(rNode.getName());
		restaurant.setDescription(rNode.getProperty("description").getString());
		restaurant.setPhoneNumber(rNode.getProperty("phoneNumber").getString());
		hotel.addRestaurant(restaurant);
	}
	
} finally {
	session.logout();
}
}}}

This code is far from beautiful, and it gets messier with every field or child you add. Now, let's assume that we have annotated the Hotel and Restaurant classes with JCROM. We then create a new JCROM instance and map the objects we need:

{{{
Jcrom jcrom = new Jcrom();
jcrom.map(Hotel.class); // this will map Restaurant as well
}}}

Now that we have initialised Jcrom, we can map a Hotel instance to JCR:

{{{
Hotel hotel = ...;
Session session = ...;
try {
	Node parentNode = session.getRootNode().getNode("Hotels");
	jcrom.addNode(parentNode, hotel);
	
	session.save();
} finally {
	session.logout();
}
}}}

And in the same way we can load it from JCR:

{{{
String hotelName = ...;
Session session = ...;
try {
	Node hotelNode = session.getRootNode().getNode("Hotels").getNode(hotelName);
	Hotel hotel = jcrom.fromNode(Hotel.class, hotelNode);
} finally {
	session.logout();
}
}}}

Pretty neat, huh? JCROM handles the mapping of nodes and child nodes, casting and assignment. And that's not all. The DAO support can abstract the JCR concepts even further, but more about that later in this guide.

== Summary ==

To summarise:
  * annotation based (needs Java 1.5)
  * lightweight, 32KB, only two external dependencies (JCR api and logging api)
  * simple to learn, easy to use (and test)
  * removes error prone boiler plate code
  * works with any JCR implementation
  * vision: do for JCR what Hibernate did for JDBC

What JCROM does not do at the moment:
  * support references
  * support same name siblings (not recommended anyway)
  * support mapping of legacy objects via XML

I find it easiest to explain by example. Therefore, this user guide is written more in a tutorial style than as a reference.

= Before we begin =

To use JCROM, you'll need the JCROM jar in your classpath. There are a few ways you can achieve this:

  * Download it directly from http://jcrom.org (note that you will need to download the external dependencies as well)
  * If you use Maven2 to manage your project, you can reference JCROM as a dependency:
  {{{
  <dependency>
	<groupId>org.jcrom</groupId>
	<artifactId>jcrom</artifactId>
	<version>1.0</version>
  </dependency>
  }}}
  * Finally, you can check out from subversion and build it yourself. You will need Maven2 for this. After you've checked out the project, cd into the jcrom folder, and run "mvn install".

= Annotating your Java classes =

To use JCROM, you need to be able to annotate the class you want to map. All the JCROM annotations are on the field level, except for one that is on the class level. I'll introduce the most important ones, and then give a table of all the annotations. Let's assume that we have the following Java class:

{{{
import java.util.Date;

public class WeblogEntry {

	private String title;
	private String excerpt;
	private String body;
	private Date publishDate;
	
	// ... getters and setters
}
}}}

We have four simple fields here. Let's look at the class after annotating it with JCROM annotations:

{{{
import java.util.Date;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class WeblogEntry {
	
	@JcrName private String name;
	@JcrProperty private String title;
	@JcrProperty private String excerpt;
	@JcrProperty private String body;
	@JcrProperty private Date publishDate;
	
	public void setTitle( String title ) {
		this.title = title;
		this.name = title;
	}
	
	// ... other getters and setters
}
}}}

Two things to notice here. First of all, we've added a new field, "name", with the annotation @JcrName. The @JcrName annotation is mandatory: each class that is to be mapped using JCROM must have a String field that is annotated with @JcrName. This will be mapped to the node name, and will therefore represent the last token in the path to the node. The reason we've created another field, rather than use the title field, is that JCROM will clean the @JcrName field when mapping to a node name ("Hello, world!" would become "Hello_world"). We therefore store the original title in the title field, and the clean version in the name field (note that in the title setter we set the name as well). 

The second thing to notice, is that we have annotated the other fields using @JcrProperty. JCROM will map all fields annotated with @JcrProperty to a property on the node. For a list of valid property types, see the table later in this chapter. @JcrProperty can be also be used for multi-value properties, but such fields need to be mapped as java.util.List, parameterized with a valid field type (more on this in the annotation reference below).

In general, to annotate your object for JCROM, you do the following:

  # Annotate a String field with @JcrName. This will store the node name (cleaned up).
  # Annotate the class with @JcrNode if you need to specify a custom node type to map to.
  # Annotate fields with @JcrProperty. Multi-valued fields should be represented as a java.util.List with a valid property parameter.
  # Annotate child objects with @JcrChildNode. The child objects must be annotated with JCROM annotations. Multiple children are represented as a java.util.List, parameterized with the child object type.
  # Annotate parent object references with @JcrParentNode.
  # Annotate file objects with @JcrFileNode.
  # Annotate files for storing read-only JCR information with @JcrUUID, @JcrCreated, or @JcrPath.

I'll now describe these steps in more detail.

Note:
  * JCROM uses field level annotation, not method level. The fields can be private. Therefore there is no requirement for getter and setter methods.
  * JCROM handles inheritance, so annotations from superclasses are automatically detected.

== Node types ==

By default, JCROM maps objects to the nt:unstructured node type (the JcrFile class is an exception, more on that later!). This is handy for many cases, as it is a node type that allows any properties and child nodes. You can get up and running very quickly using this node type, and you can always add structure later.

However, if you have stricter requirements, and want to map your Java object to a custom node type, then you can use the @JcrNode annotation. This annotation is the only JCROM annotation that works on the type level (classes, interfaces). To map your class to a custom node type, simply annotate it as follows:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrNode;

@JcrNode(nodeType = "my:type")
public class MyClass {
	@JcrName private String name;
	...
}
}}}

== Properties ==

We can map fields to JCR node properties. There are two categories of properties.

=== Custom properties ===

You can map your Java fields to custom JCR properties using the @JcrProperty annotation. The following table shows which field types are valid for @JcrProperty annotation, and what JCR type they are mapped to:

|| *Java type* || *JCR type* ||
|| String || STRING ||
|| Boolean, boolean || BOOLEAN ||
|| Double, double || DOUBLE ||
|| Integer, int || DOUBLE ||
|| Long, long || LONG ||
|| byte[] || BINARY ||
|| java.io.InputStream || BINARY ||
|| java.util.Date || DATE ||
|| java.util.Calendar || DATE ||
|| java.sql.Timestamp || DATE ||

If we try to map a class with a @JcrProperty annotated field of type other than the above, we will get an exception telling us that the type is invalid.

We can map multi-valued properties using a java.util.List, as long as the List is parameterized with one of the Java types in the table above. For example:

{{{
import java.util.List;
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrProperty private int mySingleValue;
    @JcrProperty List<String> myMultiValues;

    ...
}
}}}

The name of the JCR property will by default be the same as the name of the Java field. If you need to override this (for example to use namespaces), you can do so using the name parameter on the @JcrProperty annotation:

{{{
import org.jcrom.annotations.JcrName;
import org.jcrom.annotations.JcrProperty;

public class MyClass {

    @JcrName private String name;
    @JcrProperty(name = "my:singleValue") private int mySingleValue;

    ...
}
}}}

=== Named read-only JCR properties ===

Depending on the node types and/or mixin types you use when mapping a Java object to JCR, the JCR will create default properties. JCROM provides a set of annotations to map to those read-only properties. This is useful if you want to use these properties in your Java code:

  * *@JcrUUID* - If the node has a generated UUID stored in a jcr:uuid property (e.g. it is of the mixin type mix:referenceable), then that value will be read into the field annotated with this annotation. This must be a String field.
  * *@JcrPath* - The full path to the node representing the Java object will be read into a field annotated with this annotation. This must be a String field.
  * *@JcrCreated* - If the node has a creation date stored in a jcr:created property (e.g. it is of a type that extends nt:hierarchyNode), then that value will be read into the field annotated with this annotation. 

== Child nodes ==
